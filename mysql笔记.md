[TOC]



## 1 基础

### 1.1 DQL/DML/DDL

```
DDL 库管理
DCL 表管理
DML	表增改查
DQL 表查
```

### 1.2 Sql执行顺序

```sql
from
on
left/right
where
group by
having 
select
distanct
order by
limit
```

### 1.3 Sql执行流程

解析器(语法解析)

优化器

执行器

## 2 存储引擎

| 区别 | InnoDB                 | MyISAM                               |
| :--: | ---------------------- | ------------------------------------ |
| 事务 | 支持事务               | 不支持事务                           |
|  锁  | 行锁，操作时只锁某一行 | 表锁，即使操作一条记录也会锁住整个表 |
| 缓存 | 都缓存，内存影响性能   | 只缓存索引，不缓存真实数据           |
| 关注 | 并发些、事务、         | 简单业务，消耗少                     |

## 3 索引

### 3.1 数据结构

数据页 数据项

#### 3.1.1 B+tree概念

> Mysql InnoDB中页的默认大小为16k

一般B+树高大约为1-3层（通过主键索引查询，通常磁盘io数为1~3次）

```sql
例如：
非叶子节点存1000条目录项记录
叶子节点存100条数据记录

一层可以存放100条数据
两层可以存放1000*100条数据
三层可以存放1000*1000*100条数据
```

#### 3.1.2 B+tree注意事项

1. 根页面位置万年不变：插入数据->记录满->复制到一个新分配的页->升为目录项页
2. 非聚簇索引记录主键值
3. 一个页最少可以存储2条数据

#### 3.1.3 Hash、b+tree、btree对比

==深度越深，查找越慢==

> 全表扫描

`慢`

> Hash 

`数据存储没有顺序，且单查询快！范围查询效率低`

> 二叉搜索树

`特殊情况会导致深度非常大 O(n)`

> AVL二叉平衡搜索树

回旋查找

> B-Tree 

回旋查找

> B+Tree

支持范围查找

```txt
除叶子节点之外，其他节点不保存数据，只保存关键字和指针
叶子节点包含了所有数据的关键字以及data，叶子节点之间可以用链表连接起来–支持范围查找。
通过链表解决回旋查找
```

### 3.2 索引分类

+ 从功能逻辑上四种：`主键索引`、`唯一索引`、`普通索引`，`多列索引`
+ 从物理实现方式分为`聚簇索引`、`非聚簇索引`

#### 3.2.1 聚簇索引

`只能有一个`一般为`主键` 叶子节点存储`数据记录`  `查询效率高`

#### 3.2.2 非聚簇索引

`可以有多个` 存储`数据位置`

### 3.3 索引命令

#### 3.3.1 创建索引

```sql
create table user(
	id int primary key, --主键自动添加主键索引
	age int unique,     --唯一约束自动添加唯一索引
	phone varchar(255),
	index indx_phone(phone)--给phone加普通索引名为index_phone
)


alter table user add index indx_phone(phone);
```

#### 3.3.2 查看索引

```sql
show index from user;

show create table user;
```

#### 3.3.3 删除索引

```sql
drop index index_phone on user --删除名为index_phone索引

alter user drop index index_phone--删除名为index_phone索引

alter user drop column phone --会删除所有索引中的相关字段

```

### 3.4 索引设计

#### 3.4.1 适合设索引

+ 经常出现在where条件后的列
+ 经常group和oreder的列
+ update delete 后面where的列
+ distinct字段
+ 多表join where 和 on 列
+ 列类型小的
+ 使用字符前缀做索引`alter table user index index_address(12)`
+ 使用频繁的放联合索引左边`最左前缀`
+ 索引数量不超过==6==个

#### 3.4.2 不适合设索引

+ where中不使用的
+ 数据量小的情况
+ 大量重复数据的列上
+ 经常更新的表

### 3.5 性能分析

```
sql索引->表结构->系统配置->硬件
```

#### 3.5.1 慢查询

> 如果不是调优，不建议启动该参数，英文开启后带来一定的性能影响

```sql
--开启慢查询
set global slow_query_log='ON';
--设置阈值 1s
set global long_query_time = 1;
show global variables like '%long_query_time%';
--查看慢查询日志
show globalL status LIKE '%Slow_queries%';
```

#### 3.5.2 执行成本

> show profiles

```sql
--开启执行成本
set profiling = 'ON';
--查询所有
show profiles;
--查询最近
show prifile;
--查询第几个
show profile for query 2;
```

#### 3.5.3 执行计划

> explain

```sql
explain select * from user where id =1;
```

| 列名          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| id            | 唯一id  ==id相同为一组，从上往下执行，id值越大越先执行==     |
| select_type   | 查询类型                                                     |
| table         | 表名                                                         |
| partitions    | 匹配的分区信息                                               |
| type          | 访问方法 `system` ，` const` ， `eq_ref` ， `ref` ， ` range` ，` index` ， `ALL `。 至少要达到range级别 |
| possible_keys | 可能用到的索引                                               |
| key           | 实际用到的索引                                               |
| key_len       | 实际用到的索引长度                                           |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息       |
| rows          | 预估的需要读取的记录条数                                     |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比                 |
| extra         | 额外信息                                                     |

### 3.6 数据库优化

#### 3.6.1 查询语句优化

##### 索引优化

```sql
最左前缀，不能跳，不能断
索引字段上计算、函数、类型转化(name=123 name='123')索引失效
不等于!=或<> 索引失效
范围条件右边索引失效 范围条件放最后
is not null 索引失效
like %放左边索引失效
OR 前后存在非索引的列，索引失效
select * 回表索引失效
order by 没有使用limit索引失效
order by 排序不一致索引失效
```

##### 减少回表

`覆盖索引`：索引中已经包含了所有需要读取的列数据的查询方式

`索引下推`：用于二级索引，辅助索引 

##### 关联优化

`小表驱动大表` 被驱动表小、连接次数小，性能消耗小

`使用连接（JOIN）查询来替代子查询`

##### 分页优化



#### 3.6.2 表结构/服务器优化

#### 3.6.3 分库分表

## 4 事务

### 4.1 隔离级别

#### 读未提交RU 

事务A 可以读到事务B未提交 ==幻读、脏读、不可以重复读==

#### 读已提交RC

事务A可以读到事务B已提交的 ==幻读、不可重复读==

#### 可重复读RR

事务B提交 事务A重复读是一样的 ==幻读==

#### 串行化

事务B未提交、事务A等待

### 4.2 并发问题

#### 脏读

事务A读到了事务B未提交的数据！

#### 不可重复读

两次读查询到的不一样  `改`

#### 幻读

两次读查询到的不一样  `增删`

### 4.3 解决方案

#### 4.3.1 读写加锁 

#### 4.3.2 MVCC

> MVCC主要是基于隐藏字段、UndoLog版本链和readview来实现的

为了在并发读写时不加锁来实现提高效率

只适用于`RR RC隔离级别`

**隐藏字段**  事务ID和rollpointer指针

**版本链**数据的每次改动都会记录一条undolog日志，也就是同一条数据的不同版本，通过隐藏字段rollpointer 回滚指针串起来，形成一个链表！

**readview **用来判断当前返回哪一个版本！

readview有四个核心字段，分别是

| **m_ids**    | **min_trx_id** | **max_trx_id** | **creator_trx_id** |
| ------------ | -------------- | -------------- | ------------------ |
| 活跃的事务ID | 最小           | 最大+1         | 事务id             |

判断规则的话是分两种情况

==RC== `每次快照读生成新的readview`，根据当前的readview去和版本链中的进行比较，如果版本链中的事务id存在于当前readview，说明还未修改！如果版本链比最小还小，说明已提交，获取这个版本！，如果比最大的大，说明是新的事务修改。

==RR== `只有第一次快照读生成readview`，更具当前的readview去和版本链中的进行比较，如果存在于当前readview说明未修改，如果比版本链小，说明是已提交！

这个也解释了RC有不可重复读问题 RR是可重复读！、

RR在MVCC下不能保证不产生幻读的问题。因为如果在两次快照读中间穿插了当前读，那么ReadView会被重新生成，因此可能会导致幻读的问题产生。既第一次读到了3条数据，第二次读到了2条数据。









## 5 锁

### 5.1 类型

#### 共享锁读锁

`select * from user for share;`

#### 排它锁写锁

`select * from user for update;`

### 5.2 粒度

#### 全局锁

全局备份

#### 表锁

##### 意向锁

事务A给一行数据加上排它锁、会自动给这个表加上一个意向排它锁，

事务B执行写时不需要每行去判断是否有排它锁，只需要判断表是否有意向排它锁~

##### 元数据锁

DML操作时会加元数据锁

例如：事务A对做增删改查的时候，事务B修改表结构 

#### 行锁

##### 记录锁

锁一条记录

##### 间隙锁

不存在的记录加锁

##### 临键锁

范围加锁

### 5.3 态度

#### 乐观锁

多事务并发情况下不会发生冲突，增改的时候通过判断`版本号``时间戳`是否更改，已更改回滚重试！

`适合读多写少` 

#### 悲观锁

思想：`总有刁民想害朕` 读写操作带锁

`适合写多读少`

## 6 事务日志(x)

### 6.1 REDO LOG 

重做日志  `持久性`

### 6.2 UNDO LOG 

回滚日志 `原子性、一致性`



